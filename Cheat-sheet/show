#!/bin/bash

# cheat show - Mostrar nota por ID o últimas entradas de un archivo

# Load environment variables
if [ -f "$HOME/bin/.env" ]; then 
    set -a
    source "$HOME/bin/.env"
    set +a
fi

DIR="${CHEAT_SHEETS_DIR:-$HOME/cheat-sheet}"
INPUT=$1

if [[ -z "$INPUT" ]]; then
  echo "Uso: cheat show <id|filename> [count]"
  echo "  cheat show 20241205123456    # Mostrar nota por ID"
  echo "  cheat show bash             # Mostrar últimas 5 entradas de bash.md"
  echo "  cheat show bash 10          # Mostrar últimas 10 entradas de bash.md"
  exit 1
fi

COUNT=${2:-5}  # Por defecto mostrar 5 entradas

# Determinar si es un ID (solo números) o un nombre de archivo
if [[ "$INPUT" =~ ^[0-9]+$ ]]; then
  # Es un ID - comportamiento original
  ID=$INPUT
  
  # Buscar primero por ID completo
  FILE=$(grep -rl "^id: $ID" "$DIR"/*.md 2>/dev/null | head -n1)
  
  # Si no se encuentra y el ID tiene 6 dígitos o menos, buscar por ID corto
  if [[ -z "$FILE" ]] && [[ ${#ID} -le 6 ]]; then
    FILE=$(grep -rl "^id: .*$ID$" "$DIR"/*.md 2>/dev/null | head -n1)
    if [[ -n "$FILE" ]]; then
      # Obtener el ID completo
      ID=$(grep "^id: .*$ID$" "$FILE" | cut -d' ' -f2)
    fi
  fi
  
  if [[ -z "$FILE" ]]; then
    echo "Nota con ID $INPUT no encontrada"
    exit 1
  fi
else
  # Es un nombre de archivo - mostrar últimas entradas
  FILENAME=$INPUT
  FILE="$DIR/$FILENAME.md"
  
  if [[ ! -f "$FILE" ]]; then
    echo "Archivo $FILENAME.md no encontrado en $DIR"
    exit 1
  fi
  
  echo "Mostrando las últimas $COUNT entradas de $FILENAME.md:"
  echo "="$(printf '%.0s' {1..50})
  
  # Colores
  YELLOW='\033[1;33m'
  NC='\033[0m'  # No Color
  
  # Mostrar las últimas N entradas con formato mejorado
  OUTPUT=$(awk -v count="$COUNT" -v filename="$FILENAME" -v yellow="$YELLOW" -v nc="$NC" '
    /<!-- cheat:start -->/ {block=1; id=""; note=""; date=""; in_note=0; entry_count++}
    block && /^id:/ {id=$2}
    block && /^note:/ {in_note=1; sub("note: ?", ""); note=$0; next}
    block && in_note && !/^date:/ {note = note "\n" $0; next}
    block && /^date:/ {in_note=0; sub("date: ", ""); date=$0}
    /<!-- cheat:end -->/ {
      if(block) {
        # Extraer solo hora:minuto de la fecha
        split(date, datetime, " ")
        time = datetime[2]
        
        # Extraer últimos 6 dígitos del ID
        short_id = substr(id, length(id)-5)
        
        entries[entry_count] = yellow filename " • " time " • #" short_id nc "\n\n" note "\n"
      }
      block=0
    }
    END {
      start = (entry_count > count) ? entry_count - count + 1 : 1
      for(i = start; i <= entry_count; i++) {
        print entries[i]
      }
    }
  ' "$FILE")
  
  # Usar pager si el contenido es largo
  TOTAL_LINES=$(($(echo "$OUTPUT" | wc -l) + 3))  # +3 por el header
  TERMINAL_LINES=$(tput lines 2>/dev/null || echo 24)  # Fallback a 24 líneas
  if [[ $TOTAL_LINES -gt $TERMINAL_LINES ]]; then
    (echo "Mostrando las últimas $COUNT entradas de $FILENAME.md:"; echo "="$(printf '%.0s' {1..50}); echo; echo "$OUTPUT") | less -R
  else
    echo
    echo "$OUTPUT"
  fi
  exit 0
fi

# Colores
YELLOW='\033[1;33m'
NC='\033[0m'  # No Color

# Mostrar nota específica por ID con formato mejorado
OUTPUT=$(awk -v search="$ID" -v yellow="$YELLOW" -v nc="$NC" '
  /<!-- cheat:start -->/ {block=1; id=""; note=""; date=""; in_note=0}
  block && /^id:/ {id=$2}
  block && /^note:/ {in_note=1; sub("note: ?", ""); note=$0; next}
  block && in_note && !/^date:/ {note = note "\n" $0; next}
  block && /^date:/ {in_note=0; sub("date: ", ""); date=$0}
  /<!-- cheat:end -->/ {
    block=0
    if (id==search) {
      fname=FILENAME
      sub(/^.*\//,"",fname)
      sub(/\.md$/,"",fname)
      
      # Extraer solo hora:minuto de la fecha
      split(date, datetime, " ")
      time = datetime[2]
      
      # Extraer últimos 6 dígitos del ID
      short_id = substr(id, length(id)-5)
      
      print yellow fname " • " time " • #" short_id nc
      print ""
      print note
      print ""
    }
  }
' "$FILE")

# Usar pager si el contenido es largo, sino mostrar directo
LINE_COUNT=$(echo "$OUTPUT" | wc -l)
TERMINAL_LINES=$(tput lines 2>/dev/null || echo 24)  # Fallback a 24 líneas
if [[ $LINE_COUNT -gt $TERMINAL_LINES ]]; then
  echo "$OUTPUT" | less -R
else
  echo "$OUTPUT"
fi
